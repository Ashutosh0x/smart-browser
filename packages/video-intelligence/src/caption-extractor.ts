/**
 * AB-OS Caption Extractor
 * 
 * Extracts and normalizes captions from YouTube videos.
 * Now supports network interception for real caption capture.
 */

import { transcriptStore, TranscriptSegment } from './transcript-store';

// =============================================================================
// Types
// =============================================================================

export interface Caption {
    start: number;     // Start time in seconds
    duration: number;  // Duration in seconds
    text: string;      // Caption text
}

export interface Transcript {
    videoId: string;
    title: string;
    channel: string;
    duration: number;
    language: string;
    captions: Caption[];
    fullText: string;
}

export interface CaptionTrack {
    baseUrl: string;
    name: string;
    languageCode: string;
    isAutoGenerated: boolean;
}

// =============================================================================
// Caption Extractor
// =============================================================================

export class CaptionExtractor {
    private cache: Map<string, Transcript> = new Map();

    /**
     * Ingest captions from network interception (PRODUCTION PATH)
     * Called when NetworkInterceptor captures timedtext response
     */
    ingestFromNetwork(
        agentId: string,
        videoId: string,
        responseBody: string,
        metadata: {
            title?: string;
            channel?: string;
            duration?: number;
            language?: string;
        } = {}
    ): boolean {
        try {
            const data = JSON.parse(responseBody);
            const captions = this.parseCaptionData(data);

            if (captions.length === 0) {
                console.log('[CaptionExtractor] No captions in response');
                return false;
            }

            // Convert to TranscriptSegments
            const segments: TranscriptSegment[] = captions.map(c => ({
                start: c.start,
                end: c.start + c.duration,
                text: c.text,
            }));

            // Store in TranscriptStore
            transcriptStore.store(agentId, videoId, segments, {
                title: metadata.title,
                channel: metadata.channel,
                duration: metadata.duration,
                language: metadata.language,
                source: 'timedtext',
            });

            console.log(`[CaptionExtractor] Ingested ${segments.length} segments for ${agentId}:${videoId}`);
            return true;
        } catch (error) {
            console.error('[CaptionExtractor] Failed to ingest:', error);
            return false;
        }
    }

    /**
     * Ingest VTT format captions
     */
    ingestVTT(
        agentId: string,
        videoId: string,
        vttContent: string,
        metadata: { title?: string; channel?: string } = {}
    ): boolean {
        try {
            const segments = this.parseVTT(vttContent);

            if (segments.length === 0) {
                return false;
            }

            transcriptStore.store(agentId, videoId, segments, {
                ...metadata,
                source: 'vtt',
            });

            return true;
        } catch {
            return false;
        }
    }

    /**
     * Parse VTT format
     */
    private parseVTT(vtt: string): TranscriptSegment[] {
        const segments: TranscriptSegment[] = [];
        const lines = vtt.split('\n');
        let i = 0;

        while (i < lines.length) {
            const line = lines[i].trim();

            // Look for timestamp line: 00:00:00.000 --> 00:00:05.000
            if (line.includes('-->')) {
                const [startStr, endStr] = line.split('-->').map(s => s.trim());
                const start = this.parseVTTTime(startStr);
                const end = this.parseVTTTime(endStr);

                // Collect text lines
                i++;
                const textLines: string[] = [];
                while (i < lines.length && lines[i].trim() !== '') {
                    textLines.push(lines[i].trim());
                    i++;
                }

                if (textLines.length > 0) {
                    segments.push({
                        start,
                        end,
                        text: textLines.join(' ').replace(/<[^>]+>/g, ''), // Strip HTML tags
                    });
                }
            }
            i++;
        }

        return segments;
    }

    /**
     * Parse VTT timestamp to seconds
     */
    private parseVTTTime(timeStr: string): number {
        const parts = timeStr.split(':');
        if (parts.length === 3) {
            const [h, m, s] = parts;
            return parseInt(h) * 3600 + parseInt(m) * 60 + parseFloat(s);
        } else if (parts.length === 2) {
            const [m, s] = parts;
            return parseInt(m) * 60 + parseFloat(s);
        }
        return 0;
    }

    /**
     * Extract captions from a YouTube video page
     * Called from main process with page HTML/data
     */
    async extractFromPage(videoId: string, pageData: {
        title?: string;
        channel?: string;
        duration?: number;
        captionTracks?: CaptionTrack[];
        playerResponse?: any;
    }): Promise<Transcript | null> {
        // Check cache first
        if (this.cache.has(videoId)) {
            return this.cache.get(videoId)!;
        }

        try {
            // Try to get caption tracks from player response
            const tracks = pageData.captionTracks ||
                this.extractCaptionTracks(pageData.playerResponse);

            if (!tracks || tracks.length === 0) {
                console.log('[CaptionExtractor] No caption tracks found');
                return null;
            }

            // Prefer manual captions over auto-generated
            const track = tracks.find(t => !t.isAutoGenerated) || tracks[0];

            // Fetch captions from track URL
            const captions = await this.fetchCaptions(track.baseUrl);

            const transcript: Transcript = {
                videoId,
                title: pageData.title || 'Unknown',
                channel: pageData.channel || 'Unknown',
                duration: pageData.duration || 0,
                language: track.languageCode,
                captions,
                fullText: this.buildFullText(captions),
            };

            // Cache for subsequent requests
            this.cache.set(videoId, transcript);

            return transcript;
        } catch (error) {
            console.error('[CaptionExtractor] Error:', error);
            return null;
        }
    }

    /**
     * Extract caption tracks from YouTube player response
     */
    private extractCaptionTracks(playerResponse: any): CaptionTrack[] {
        if (!playerResponse) return [];

        try {
            const captions = playerResponse.captions?.playerCaptionsTracklistRenderer;
            if (!captions?.captionTracks) return [];

            return captions.captionTracks.map((track: any) => ({
                baseUrl: track.baseUrl,
                name: track.name?.simpleText || track.languageCode,
                languageCode: track.languageCode,
                isAutoGenerated: track.kind === 'asr',
            }));
        } catch {
            return [];
        }
    }

    /**
     * Fetch captions from timedtext URL
     */
    private async fetchCaptions(baseUrl: string): Promise<Caption[]> {
        // Add fmt=json3 for JSON format
        const url = new URL(baseUrl);
        url.searchParams.set('fmt', 'json3');

        const response = await fetch(url.toString());
        if (!response.ok) {
            throw new Error(`Failed to fetch captions: ${response.status}`);
        }

        const data = await response.json();
        return this.parseCaptionData(data);
    }

    /**
     * Parse YouTube caption JSON format
     */
    private parseCaptionData(data: any): Caption[] {
        if (!data.events) return [];

        const captions: Caption[] = [];

        for (const event of data.events) {
            // Skip non-caption events (like window styles)
            if (!event.segs) continue;

            const text = event.segs
                .map((seg: any) => seg.utf8 || '')
                .join('')
                .trim();

            if (text) {
                captions.push({
                    start: (event.tStartMs || 0) / 1000,
                    duration: (event.dDurationMs || 0) / 1000,
                    text,
                });
            }
        }

        return captions;
    }

    /**
     * Build full transcript text from captions
     */
    private buildFullText(captions: Caption[]): string {
        return captions
            .map(c => c.text)
            .join(' ')
            .replace(/\s+/g, ' ')
            .trim();
    }

    /**
     * Get transcript with timestamps for timeline view
     */
    getTimestampedTranscript(transcript: Transcript): string {
        return transcript.captions
            .map(c => `[${this.formatTime(c.start)}] ${c.text}`)
            .join('\n');
    }

    /**
     * Format seconds to MM:SS
     */
    private formatTime(seconds: number): string {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    /**
     * Clear cache for a specific video or all
     */
    clearCache(videoId?: string): void {
        if (videoId) {
            this.cache.delete(videoId);
        } else {
            this.cache.clear();
        }
    }
}

